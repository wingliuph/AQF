#-*- codeing = utf-8 -*-
#@TIME:     2021/2/4 14:17 
#@Author:   刘澎浩
#@File:     TDX2SQLite1.0.py
#@Software: PyCharm
from __future__ import unicode_literals, division
import pandas as pd
import os
import struct
import glob
import datetime
import sqlite3
import talib as ta


class TdxReader(object):
    def unpack_records(self, format, data):
        record_struct = struct.Struct(format)
        return (record_struct.unpack_from(data, offset)
                for offset in range(0, len(data), record_struct.size))


class TdxBatReader(TdxReader):
    """
            读取tdx日线数据
    """

    def __init__(self, vipdoc_path=None, exchange=None):
        self.vipdoc_path = vipdoc_path
        self.exchange = exchange

    def generate_filename(self, codeaddr):
        # exchange是交易所，有SZ和SH
        fname = codeaddr

        return fname

    def parse_data_by_file(self, fname):
        if not os.path.isfile(fname):
            print('no data, pleaes check path %s', fname)

        if exchange == 'ds':
            with open(fname, 'rb') as f:
                content = f.read()
                return self.unpack_records('<IffffIII', content)
            return []
        else:
            with open(fname, 'rb') as f:
                content = f.read()
                return self.unpack_records('<IIIIIfII', content)
            return []

    def get_df_by_file(self, fname):
        if not os.path.isfile(fname):
            print('no tdx kline data, pleaes check path %s', fname)

        security_type = self.get_security_type(fname)
        if security_type not in self.SECURITY_TYPE:
            print("Unknown security type\n")
            raise NotImplementedError

        coefficient = self.SECURITY_COEFFICIENT[security_type]
        data = [self._df_convert(row, coefficient) for row in self.parse_data_by_file(fname)]

        df = pd.DataFrame(data=data, columns=('date', 'open', 'high', 'low', 'close', 'amount', 'volume'))
        # df.index = pd.to_datetime(df.日期)

        df['change'] = round(df['close'].diff() / df['close'] * 100, 3)  # 涨跌娶4位有效数字
        df = df.sort_values(by='date', ascending=False)#计算涨跌幅之后，再按日期降序排列
        df.drop(0, inplace=True)#删除第一行的NaN，change没有数据

        return df[['date', 'open', 'high', 'low', 'close','change', 'amount', 'volume']]

    def _df_convert(self, row, coefficient):
        t_date = str(row[0])
        datestr = t_date[:4] + "-" + t_date[4:6] + "-" + t_date[6:]

        new_row = (
            datestr,
            row[1] * coefficient[0],
            row[2] * coefficient[0],
            row[3] * coefficient[0],
            row[4] * coefficient[0],
            row[5],
            row[6] * coefficient[1]
        )
        return new_row

    def get_security_type(self, fname):

        exchange = str(fname[-12:-10]).lower()
        code_head = fname[-10:-8]

        if exchange == self.SECURITY_EXCHANGE[0]:
            if code_head in ["00", "30"]:
                return "SZ_A_STOCK"
            elif code_head in ["20"]:
                return "SZ_B_STOCK"
            elif code_head in ["39"]:
                return "SZ_INDEX"
            elif code_head in ["15", "16"]:
                return "SZ_FUND"
            elif code_head in ["10", "11", "12", "13", "14"]:
                return "SZ_BOND"
        elif exchange == self.SECURITY_EXCHANGE[1]:
            if code_head in ["60"]:
                return "SH_A_STOCK"
            elif code_head in ["90"]:
                return "SH_B_STOCK"
            elif code_head in ["00", "88", "99"]:
                return "SH_INDEX"
            elif code_head in ["50", "51"]:
                return "SH_FUND"
            elif code_head in ["01", "10", "11", "12", "13", "14"]:
                return "SH_BOND"
        else:
            return "DS_BOND"
            print("Unknown security exchange !\n")

    SECURITY_EXCHANGE = ["sz", "sh"]
    SECURITY_TYPE = ["SH_A_STOCK", "SH_B_STOCK", "SH_INDEX", "SH_FUND", "SH_BOND", "SZ_A_STOCK", "SZ_B_STOCK",
                     "SZ_INDEX", "SZ_FUND", "SZ_BOND", "DS_BOND"]
    SECURITY_COEFFICIENT = {"SH_A_STOCK": [0.01, 0.01], "SH_B_STOCK": [0.001, 0.01], "SH_INDEX": [0.01, 1.0],
                            "SH_FUND": [0.001, 1.0], "SH_BOND": [0.001, 1.0], "SZ_A_STOCK": [0.01, 0.01],
                            "SZ_B_STOCK": [0.01, 0.01], "SZ_INDEX": [0.01, 1.0], "SZ_FUND": [0.001, 0.01],
                            "SZ_BOND": [0.001, 0.01], "DS_BOND": [1, 10]}

def tdxfloder2sqlite(j_add=None, exchange=None, DB_Name=None, table_name=None, codename=None):
    '''
    通达信vipdoc地址j_add=None,交易所exchange=None,数据库地址和名字DB_Name = None,数据表名字table_name = None,股票字典codename=None
    '''
    addr = os.path.join(j_add, '%s' % (exchange), 'lday')
    os.chdir(addr)
    fname_list = glob.glob('*.day')

    for fname in fname_list:
        try:
            print(fname)
            df = tdx_read.get_df_by_file(fname)
            # df = df.sort_index(ascending=False)
            refresh_date = datetime.date.today()  # 今天日期
            print(refresh_date)
            df['re_date'] = refresh_date

            df.insert(0, 'Name', codename[fname])
            conn = sqlite3.connect(DB_Name)
            cursor = conn.cursor()
            print('连接数据库%s成功' % (DB_Name))

            try:
                df.to_sql(table_name, con=conn, if_exists='append', index='False')
            except Exception as e:
                print(e)
                conn.rollback()  # 回滚
                print('插入数据到表失败')

            # 批量插入之后再执行事务提交
            conn.commit()
            # 关闭游标
            cursor.close()
            # 断开数据库连接
            conn.close()

        except:
            pass

if __name__ == '__main__':
    tdx_read = TdxBatReader()

    j_add = 'D:\\Program Files (x86)\\tdx\\vipdoc'
    exchanges = ['ds','sh','sz']

    DB_Name = 'E:\\sqlite3\\TDX.db'
    table_name='index'


    codename = pd.read_csv('E:\\sqlite3\\code.csv')
    codename = dict(zip(codename['代码'],codename['名字']))
    for exchange in exchanges:
        tdxfloder2sqlite(j_add,exchange,DB_Name,table_name,codename)
    print(str(datetime.date.today()) +'数据保存完毕！')
